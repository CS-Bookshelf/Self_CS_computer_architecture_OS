<aside>
📎

- 프로세스가 무엇인지?
- 프로세스가 실행되는 과정 알아보기
</aside>

## 프로세스 직접 확인하기

### 프로세스

- 포그라운드 프로세스 - 사용자가 보는 앞에서 실행되는 프로세스
- 백그라운드 프로세스 - 사용자가 보지 못하는 뒤에서 실행되는 프로세스
    - 데몬(UNIX) / 서비스(Window) - 사용자와 상호작용 하지 않고 묵묵히 정해진 일 수행하는 백그라운드 프로세스

## 프로세스 제어 블록

### 프로세스 제어 블록 (PCB)

- 프로세스들은 정해진 시간만큼 CPU를 이용하고, 타이머 인터럽트(타임아웃 인터럽트)가 발생하면 다른 프로세스에게 차례 양보
- 빠르게 번갈아 수행되는 프로세스의 실행 순서 관리
- 커널 영역에 존재
- 프로세스를 식별하기 위한 정보들 저장.
- 프로세스 생성 시에 만들어지고 끝나면 폐기

### 프로세스 ID

- 프로세스를 식별하기 위해 부여하는 고유한 번호

### 레지스터 값

- 자신의 차례에 이전까지 사용했던 레지스터의 중간값들 복원
    
    → 이전까지 진행했던 작업들 이어 실행
    

### 프로세스 상태

- 현재 프로세스가 어떤 상태인지 저장
    - 입출력장치를 사용하기 위해 기다리는가?
    - CPU를 사용하기 위해 기다리는가?
    - CPU를 이용하고 있는 상태인가?
        
        등등..
        

### 메모리 관리 정보

- 프로세스마다 메모리에 저장된 위치가 다르기에 프로세스의 주소 정보가 필요
- 베이스 레지스터, 한계 레지스터 값 같은 정보 저장.
- 페이지 테이블 정보 저장

### 사용한 파일과 입출력장치 목록

- 프로세스 실행과정에서 특정 입출력장치나 파일을 사용하면 PCB에 해당 내용 명시됨
    - 어떤 파일을 열었는지, 어떤 입출력장치가 이 프로세스에 할당 됐는지에 대한 정보

## 문맥 교환

### 문맥(Context)

- 프로세스 수행을 재개하기 위해 기억해야 할 정보
    - PCB에 기록되는 정보들

### 문맥 교환

- 기존 프로세스의 문맥을 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것.

## 프로세스의 메모리 영역

### 코드 영역

- 텍스트 영역이라고도 불린다.
- 기계어로 이루어진 명령어 저장
- CPU가 실행할 명령어가 포함돼 쓰기가 금지 돼 있다.
    - 읽기 전용
- 정적 할당 영역

### 데이터 영역

- 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간
    - 전역 변수
- 정적 할당 영역

### 힙 영역

- 프로그래머가 직접 할당할 수 있는 저장 공간
- 공간 사용 후에는 반환해야 한다.
    - 반환 하지 않는다면 **‘데이터 누수’(memory leak)** 발생
- 동적 할당 영역

### 스택 영역

- 데이터를 일시적으로 저장하는 공간
- 데이터 영역과 달리 잠깐 쓰다가 말 값들이 저장되는 공간
    - 매개 변수, 지역 변수

## 마무리

### 키워드

- **프로세스**
    
    → **프로세스**는 실행 중인 프로그램. 프로세스의 종류에는 포그라운드 프로세스와 백그라운드 프로세스가 있다.
    
- **프로세스 제어 블록**
    
    → 운영체제는 **프로세스 제어 블록**을 통해 여러 프로세스를 관리한다.
    
- **문맥 교환**
    
    → 프로세스 간에 실행을 전환하는 것
    
- **프로세스 사용자 영역**
    
    → **프로세스 사용자 영역**에 크게 코드 영역, 데이터 영역, 스택 영역, 힙 영역으로 나뉘어 배치된다.
    

### 확인 문제

- 사용자와 상호작용 하지 않는 프로세스는 존재한다.
- 문맥 교환이 지나치게 자주 수행되면 문맥 교환에 드는 오버헤드로 인해 좋지 않다.

## 질문 사항

### Q1. 문맥 교환(Context Switching)이 무엇이며, 이 과정에서 프로세스 제어 블록(PCB)은 어떤 역할을 하는지 설명해주세요. 만약 문맥 교환이 너무 자주 발생하면 어떤 문제가 생길 수 있을까요?

- 정답
    
    **문맥 교환(Context Switching)**이란 CPU가 여러 프로세스를 번갈아 실행하기 위해, 현재 실행 중인 프로세스를 다른 프로세스로 **교체하는 과정**을 말합니다. 이때 **프로세스 제어 블록, 즉 PCB가 핵심적인 역할**을 합니다.
    
    PCB는 **프로세스의 실행 상태 정보를 저장하는 데이터 구조**인데, 쉽게 비유하자면 여러 책을 동시에 읽을 때 사용하는 '책갈피'와 같습니다. 
    
    A라는 책을 읽다가 B라는 책을 읽으려면, A 책의 읽던 페이지에 책갈피를 꽂아두고 B 책을 펼치는 것과 같습니다. 여기서 **이 책갈피가 바로 PCB**이고, 읽던 페이지 정보가 바로 문맥(Context)에 해당합니다. PCB에는 다음에 실행할 명령어의 위치(PC), 레지스터 값 등이 저장됩니다.
    
    그리고 문맥 교환이 너무 잦아지면 **오버헤드(Overhead) 문제**가 발생하여 성능이 저하됩니다.
    왜냐하면 문맥 교환이 일어나는 동안, 즉 기존 프로세스의 상태를 PCB에 저장하고 새로운 프로세스의 상태를 CPU에 불러오는 동안에는 **CPU가 실질적인 연산을 처리하지 못하기 때문**입니다. 이 전환 작업 자체가 비용(cost)인 셈입니다. 따라서 문맥 교환이 빈번해질수록 실제 작업에 쓰여야 할 CPU 시간이 전환 작업에 낭비되어 **시스템 전체의 성능 저하**로 이어집니다.
    

### Q2. 프로세스의 메모리 구조에서 스택(Stack) 영역과 힙(Heap) 영역은 어떻게 다른가요? 각각 어떤 데이터가 저장되고, 언제 사용되는지 예를 들어 설명해주세요.

- 정답
    
    
    스택(Stack)과 힙(Heap)은 모두 메모리 공간이지만, 가장 큰 차이점은 **메모리의 할당 방식**과 **관리 주체**에 있습니다. 결론부터 말씀드리면, **스택은 컴파일러가 자동으로 관리**하는 '정적'인 공간이고, **힙은 프로그래머가 직접 관리**해야 하는 '동적'인 공간입니다.
    
    **스택**은 '정해진 크기의 책상'에 비유할 수 있습니다. 함수가 호출될 때마다 해당 함수에 필요한 지역 변수나 매개 변수들이 책상 위에 순서대로 착착 쌓였다가, 함수 실행이 끝나면 순서대로 바로 치워집니다. 이 모든 과정은 **컴파일러가 알아서 처리**해주기 때문에 속도가 매우 빠르고 편리합니다.
    하지만 책상이 정해져 있다 보니, 너무 많은 작업을 올리거나 깊은 재귀 함수를 호출하면 책상이 넘치는 '스택 오버플로우'가 발생할 수 있습니다.
    
    반면에 **힙**은 '필요할 때마다 빌려 쓰는 넓은 창고'와 같습니다. 프로그램 실행 중에 데이터의 크기를 예측할 수 없을 때, 예를 들어 사용자 입력에 따라 크기가 변하는 배열이나 객체를 저장할 때 사용됩니다.
    프로그래머가 **`malloc`이나 `new` 같은 명령어로 직접 창고 공간을 요청해서 사용**하고, 사용이 끝나면 **`free`나 `delete`로 직접 반납**해야 합니다. 만약 반납하는 것을 잊으면, 그 공간을 계속 차지하게 되어 더 이상 사용할 공간이 없어지는 **'메모리 누수(Memory Leak)'** 문제가 발생할 수 있습니다.
    
    ### 핵심 차이 요약
    
    | 구분 | 스택 (Stack) | 힙 (Heap) |
    | --- | --- | --- |
    | **할당 방식** | **정적 할당** (컴파일 시 크기 결정) | **동적 할당** (실행 시 크기 결정) |
    | **관리 주체** | **컴파일러** (자동 관리) | **프로그래머** (수동 관리) |
    | **생명 주기** | 함수 호출 시 생성, 함수 종료 시 소멸 | 프로그래머가 할당/해제 |
    | **속도** | 빠름 | 상대적으로 느림 |
    | **주요 데이터** | 지역 변수, 매개 변수 | 객체, 크기가 불확실한 데이터 |
    | **문제점** | 스택 오버플로우 | **메모리 누수** |
